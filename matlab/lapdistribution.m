%% Generate Multivariate Mixture of Laplacian Distributions
% Creates a joint pdf f(x) for a combination of independent laplacians in
% R^n.
%
% Inputs:
% mu = m x n vector, denoting the mean of the laplacian in R^n
% sigma = m x n variance vector, where each element is the variance of that
% component in R^n. This will generate a diagonal matrix with the elements
% in sigma(i,:).
%
% Outputs:
% f = a mixture of laplacians with independent components. This is 
% generated by summing the pdfs of the laplacians centerd at mu(i,:) with 
% variances given by sigma(:,i), for each i. This mixture of laplacian pdfs
% will then be normalized so that the integral is 1.
% If the input X is a k x n matrix, the output will be a k x 1 vector of 
% probability values at each point.
function fx = lapdistribution(mu, sigma)
    % Validate inputs
    if nargin ~= 2
        error('Input must have 2 arguments');
    end
    if ~all(sigma > 0)
        error('Sigma values must all be positive.');
    end
    % Get the dimension of the space
    n = size(mu,2);
    
    % Get the number of laplacians
    m = size(mu,1);
    
    % The joint pdf of X is the multiplication of the marginals, since they
    % are all independent. Each marginal is given by the function
    % fi(xi) = 1/(2b) * exp(-1/b * |xi - mu(i)|)
    % with sigma^2 = 2b^2
    
    % First, compute the b-values
    bs = sqrt(sigma ./ 2);
    
    % Determine the number of points in x, giving "k"
    numPoints = @(x) size(x,1);
    % Reshape x so that it is a 1 x n x k matrix, to be able to subtract
    % mus easily and compute the marginals.
    make3D = @(x) reshape(x',1,n,numPoints(x));
    
    % Function to reshape a 1 x 1 x k matrix to be a k x 1 vector
    
    % The 1 x n x k x-matrix, when you subtract mu, results in a m x n x k
    % matrix. Taking the product along dimension 2 to get a m x 1 x k
    % matrix, we see that element (i,1,j) is the probability of point j at
    % laplacian i. By summing up the matrix along dimension 1, we get a 
    % 1 x 1 x k matrix where (1,1,j) is the probability of point j on the
    % sum of the distributions. Reshaping this to be a k x 1 vector and
    % dividing by n (the integral of the sum is the sum of the integrals,
    % which is the number of laplacians == m) yields the probability of 
    % each point along the whole mixture distribution.
    fx = @(x) reshape(...
            sum( ...
                prod(exp(-abs(make3D(x) - mu)./bs) ./ (2*bs), 2) ...
            , 1) ./ m,...
         numPoints(x),1);
    
%     % Compute the determinant of sigma, which is the parameter lambda in
%     % the covariance matrix of the multivariate laplacian
%     % (sigma = lambda * gamma)
%     lambda = det(sigma);
%     % Compute the scaling parameters which go in front of most parts of
%     % the equation
%     twoOverLambda = 2 / lambda;
%     sqrt2lambda = sqrt(twoOverLambda);
%     
%     % Compute the dimension, which in the paper is labelled R^d
%     d = size(mu,2);
%     
%     % Now compute gamma, which by the equation above is the covariance
%     % matrix scaled to have determinant 1
%     gamma = sigma / lambda;
%     
%     % Compute the modified bessel function of the second kind,
%     % K_{(d/2)-1}(sqrt(2/lambda) q(y))
%     besself = @(x) besselk( (d/2)-1, sqrt2lambda * normGamma(x,mu,gamma));
%     
%     % Compute the denominator of the distribution, sqrt( lambda/2 *
%     % q(y))^(d/2)-1, as a function handle
%     denomf = @(x) sqrt(lambda / 2 * normGamma(x,mu,gamma))^((d/2)-1);
%     
%     % Get the constant value
%     constant = 1/((2*pi)^(d/2)) * 2 / lambda;
%     
%     % Now put them together
%     fx = @(x) constant * besself(x) / denomf(x);
% 
%     fx = @(x) mvlappdf(x,mu,sigma);
% end
% 
% function y = mvlappdf(x,mu,sigma)
%     if ~isscalar(x)
%         x = reshape(x,[],2);
%     end
%     k = size(mu,2);
%     nu = (2 - k)/2;
%     xsigma = x / sigma * x';
%     musigma = mu / sigma * mu';
%     bessel = besselk(nu, sqrt((2 + musigma)*xsigma));
%     middle = (xsigma / (2 + musigma))^(nu/2);
%     left = 2*exp(x / sigma * mu') / ((2*pi)^(k/2) * sqrt(det(sigma)));
%     y = left * middle * bessel;
% end
% 
% % Simplification function to compute q(y) = (y-mu)'G^-1*(y-mu)
% function q = normGamma(x,mu,gamma)
%     % Make x into a row vector
%     if ~isscalar(x)
%         x = reshape(x,[],2);
%     end
%     
%     % Make sure x is the right size
%     assert(size(x,2) == size(mu,2), ...
%         sprintf('Laplacian input must be of dimension %d',size(mu,2)));
%     % Now compute the correct q(x), using matrix right division instead of
%     % an inverse to improve speed.
%     q = ((x - mu) / gamma) * transpose(x - mu);  
% end